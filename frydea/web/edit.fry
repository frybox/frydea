from fryhcs import Element
from fryui import Icon, Button
from frydea.models import Card

def Edit(items):
  empty_card = Card()
  def comp(item):
    if isinstance(item, Card):
      return <EditorCard refall=(editItems) card={item} />
    else:
      return <CardSeparator refall=(editItems) {**item} />
  <template>
    <div ref=(container)
         bg-primary-elx box-border h-full overflow-auto
         @keydown=(handleCardKey)>
      <EditorCard frytemplate ref=(template) card={empty_card} />
      {comp(item) for item in items}
      <div ref=(oparea) w-full text-center mt-30px>
        <Button @click=(newDraftCard) wide info>
          <Icon type="plus" class="h-8 w-8"/>
        </Button>
      </div>
    </div>
  </template>
  <script>
    import { cardManager } from './frydea.js';
    editItems = editItems ? editItems : [];
    document.addEventListener('keydown', function(e) {
        const active = document.activeElement;
        if (e.code === 'Escape' && (!active || !active.frycomponents)) {
            const len = editItems.length;
            if (len > 0) {
                const item = editItems[len-1];
                if (item.fryname === 'CardSeparator') {

                }
                editItems[len-1].focus();
            }
        }
    });
    
    const newDraftCard = async () => {
        const newcard = await template.create();
        container.insertBefore(newcard.fryelement, oparea);
        editItems.push(newcard);
        newcard.toCommandMode();
        newcard.fryelement.scrollIntoView();
        return newcard;
    };


    const handleCardKey = (e) => {
      console.log(e);
      if (!e.target.frycomponents) {
        return;
      }
      let currentCard = e.target.frycomponents[0];
      const toCommandMode = () => {
        currentCard.toCommandMode();
        e.preventDefault();
      };
      const moveDown = () => {
        const index = editItems.indexOf(currentCard);
        if (index >= 0 && index+1 < editItems.length) {
          currentCard = editItems[index+1];
          currentCard.focus();
        }
      }
      const moveUp = () => {
        const index = editItems.indexOf(currentCard);
        if (index > 0) {
          currentCard = editItems[index-1];
          currentCard.focus();
        }
      }
      const moveLeft = () => {
        console.log('moveLeft');
      }
      const moveRight = () => {
        if (this.isReady) {
          let rect = currentCard.fryelement.getBoundingClientRect();
          console.log(rect);
          let middle = rect.top + rect.height/2;
          const previewCard = this.g.previewArea.closest(middle);
          if (previewCard) previewCard.focus();
        }
        console.log('moveRight');
      }
      const deleteCard = (force=false) => {
        if (!force) {
          
        }
        console.log('deleteCard');
      }
      const broadenCard = () => {
        this.fryparent.broaden();
      }
      const narrowCard = () => {
        this.fryparent.narrow();
      }
      const saveCard = async (all=false) => {
        if (!all) {
          await currentCard.save();
        } else {
          for (const card of editItems) {
            await card.save();
          }
          console.log(`all of ${editItems.length} cards are saved.`);
        }
      }
      const previewCard = async () => {
        if (this.isReady) {
          const cardId = currentCard.model.cardId;
          await this.g.previewArea.preview({cardId});
        }
      }
      const cardKeyMap = {
        Enter: toCommandMode,
        KeyI: toCommandMode,
        KeyJ: moveDown,
        ArrowDown: moveDown,
        KeyK: moveUp,
        ArrowUp: moveUp,
        KeyH: moveLeft,
        ArrowLeft: moveLeft,
        KeyL: moveRight,
        ArrowRight: moveRight,
        KeyA: newDraftCard,
        KeyD: () => {deleteCard(e.shiftKey)},
        KeyB: broadenCard,
        KeyN: narrowCard,
        KeyW: () => {saveCard(e.shiftKey)},
        KeyP: previewCard,
      }
      if (e.code in cardKeyMap) {
        cardKeyMap[e.code]();
      }
    };

    if (editItems.length > 0) {
      editItems[editItems.length-1].focus();
    }

    const newItem = async (type, direction, args, item) => {
      const index = editItems.indexOf(item);
      if (index === -1) {
        throw `Invalid item ${item}`;
      }
      let template;
      if (type === 'card')
        template = cardTemplate;
      else
        template = separatorTemplate;
      const newitem = await template.create(args);
      if (direction === 'before') {
        container.insertBefore(newitem.fryelement, item.fryelement);
        editItems.splice(index, 0, newitem);
      } else {
        if (index === editItems.length-1) {
          container.appendChild(newitem.fryelement);
          editItems.push(newitem);
        } else {
          item = editItems[index+1];
          container.insertBefore(newitem.fryelement, item.fryelement);
          editItems.splice(index+1, 0, newitem);
        }
      }
      return newitem;
    };

    this.newCardBefore = async (args, item) => {
        return newItem('card', 'before', args, item);
    };

    this.newCardAfter = async (args, item) => {
      return newItem('card', 'after', args, item);
    };

    this.newSeparatorBefore = async (args, item) => {
      return newItem('separator', 'before', args, item);
    }

    this.newSeparatorAfter = async (args, item) => {
      return newItem('separator', 'after', args, item);
    }

    this.removeItem = (item) => {
      const index = editItems.indexOf(item);
      editItems.splice(index, 1);
      item.fryelement.remove();
    };
    
    this.closest = (y) => {
      let delta = 999999999;
      let card = null;
      for (const c of editItems) {
        const rect = c.fryelement.getBoundingClientRect();
        const middle = rect.top + rect.height/2;
        const d = Math.abs(middle-y);
        if (d < delta) {
          delta = d;
          card = c;
        }
      }
      return card;
    }
  </script>

def CardSeparator(min_cid, max_cid, count):
  <template>
    <div>
      <Button ref=(upButton) @click=(expandUp) secondary block>
        ...
      </Button>
      <div text-center>
        [{count}](countSignal)
      </div>
      <Button ref=(downButton) @click=(expandDown) secondary block>
        ...
      </Button>
    </div>
  </template>
  <script minCid={min_cid} maxCid={max_cid} {count}>
    import { signal } from 'fryhcs';
    import { cardManager } from './frydea.js';

    const countSignal = signal(count);
    const expandUp = () => {
      const len = Math.min(count, 5);
      const cids = cardManager.sliceRight(minCid, len);
      const newCount = count - len;
      for (const cid of cids) {
        const card = {cid};
        this.fryparent.newCardBefore({card}, this);
      }
      if (newCount === 0) {

      }
    };

    this.focusUp = () => { upButton.focus(); };
    this.focusDown = () => { downButton.focus(); };
  </script>


def EditorCard(card):
  time = card.update_time.strftime('%Y-%m-%d %H:%M')
  <template>
    <div mx-4px w-sub,100%,8px min-h-200px mb-20px
         border border-gray-bdx rounded-md
         focus="outline outline-4 outline-primaryax"
         has-focus="outline outline-2 outline-primaryax"
         flex flex-col
         tabindex="-1"
         ref=(elContainer)>
      <div flex-none h-30px w-full
           flex justify-between 
           bg-gray-el border border-gray-bdx>
        <div flex>
          <Icon type="file-text"/>
          <p>[{card.id}](cardModel.displayCid)</p>
        </div>
        <p>[{time}](cardModel.displayTime)</p>
      </div>
      <div ref=(elContent)
           flex-auto w-full
           bg-secondary-bg overflow-hidden>
      </div>
      <div flex-none w-full h-30px
           bg-gray-el border border-gray-bdx>
      </div>
    </div>
  </template>
  <script card={card.todict()} cardId={0}>
    import { EditorState } from "@codemirror/state";
    import { EditorView, basicSetup } from "codemirror";
    import { markdown } from "@codemirror/lang-markdown";
    import { vim, CodeMirror} from "@replit/codemirror-vim";
    import { cardManager } from "./frydea.js";
    import { oneDark } from "@codemirror/theme-one-dark";

    let editor;
    let cardModel;
    if (cardId) {
      // 前端已经有了该卡片模型对象，如已经建了预览卡片
      cardModel = cardManager.getCard(cardId);
    } else {
      // 调用createCard的三种情况都有可能
      cardModel = await cardManager.createCard(card);
    }

    CodeMirror.commands.save = async () => {
      await cardModel.save();
    }

    const createDoc = () => {
      const updator = EditorView.updateListener.of((update) => {
          if (update.docChanged) {
              cardModel.content.value = update.state.doc.toString();
          }
      });
      const frytheme = EditorView.theme({
          "&": {
            color: "white",
            backgroundColor: "#034"
          },
          ".cm-content": {
            caretColor: "#0e9",
            fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,"Liberation Mono", "Courier New", monospace',
          },
          "&.cm-focused .cm-cursor": {
            borderLeftColor: "#0e9"
          },
          "&.cm-focused .cm-selectionBackground, ::selection": {
            backgroundColor: "#074"
          },
          ".cm-gutters": {
            backgroundColor: "#045",
            color: "#ddd",
            border: "none"
          }
        }, {dark: true})

      const state = EditorState.create({
        doc: cardModel.content.peek(),
        extensions: [
          vim(),
          basicSetup,
          markdown(),
          EditorView.lineWrapping,
          updator,
          frytheme,
          //oneDark,
        ]
      })
      return state;
    }

    const createEditor = () => {
      const state = createDoc();
      if (editor) {
        editor.setState(state);
      } else {
        elContent.innerHTML = '';
        editor = new EditorView({
          state,
          parent: elContent,
        });
      }
    }

    createEditor();

    this.toCommandMode = () => {
      editor.focus();
    }

    this.focus = () => {
      elContainer.focus();
    }

    this.save = async () => {
      await cardModel.save();
    }

    this.model = cardModel;
  </script>

